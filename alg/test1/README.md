# test1
目标：  
将如下内容的后台接口数据:  
```
var data = [{
  "province": "浙江",
  "city": "杭州",
  "name": "西湖"
}, {
  "province": "四川",
  "city": "成都",
  "name": "锦里"
}, {
  "province": "四川",
  "city": "成都",
  "name": "方所"
}, {
  "province": "四川",
  "city": "阿坝",
  "name": "九寨沟"
}]
```  
格式化成层级结构:  
```
var data = [{
  "value": "浙江",
  "children": [{
    "value": "杭州",
    "children": [{
      "value": "西湖"
    }]
  }]
}, {
  "value": "四川",
  "children": [{
    "value": "成都",
    "children": [{
      "value": "锦里"
    }, {
      "value": "方所"
    }]
  }, {
    "value": "阿坝",
    "children": [{
      "value": "九寨沟"
    }]
  }]
}]
```


## fn1
这怕是我想到的最糟的格式化方法了。。。写着都觉得这方法凉透。  
- 先对数据进行分级排序
- 再逐层比较和插入到结果需要的数据格式中去，因为已经排序好了，所以只需要往最后一个里面插入数据即可  

缺点，全是缺点：  
1. 更深点的就直接原地爆炸
2. 没有对原数据的key进行参数化，业务key写在方法内部
3. sort方法在数据源庞大的情况下的性能消耗
4. 全是缺点。。  

## fn2  
针对fn1的第2点进行优化。  
通过将对象key进行参数化传入，定义方法时可以不用关心对象内部属性名是什么。  

缺点： 
1. 只是写死的三层结构，如果更深无法处理
2. 对每层结构的数据单独封装格式，代码复用性差，可维护性差  


## fn3
针对fn2的几点再次进行优化。  
首先结构层级数无法确定的情况下，首先想到的就是递归方法。我先试试.. 通过，但是性能。。


## fn4
网上搜到的trie树    




